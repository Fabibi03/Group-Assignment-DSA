import ballerina/lang.value;
import ballerina/log;
import ballerinax/kafka;
configurable string groupId = &quot;standard-delivery-group&quot;;
configurable string consumeTopic = &quot;standard-delivery&quot;;
configurable string produceTopic = &quot;delivery-confirmations&quot;;
public function main() returns error? {
    kafka:Consumer kafkaConsumer = check createKafkaConsumer();
    log:printInfo(&quot;Standard delivery service started. Waiting for requests...&quot;);
    check startConsumerLoop(kafkaConsumer);
}
function createKafkaConsumer() returns kafka:Consumer|error {
    kafka:ConsumerConfiguration consumerConfigs = {
        groupId: groupId,
        topics: [consumeTopic],
        pollingInterval: 1,
        offsetReset: &quot;earliest&quot;
    };
    return new (kafka:DEFAULT_URL, consumerConfigs);
}
function startConsumerLoop(kafka:Consumer kafkaConsumer) returns error? {
    while true {
        kafka:AnydataConsumerRecord[] records = check kafkaConsumer-&gt;poll(1);
        check processRecords(records);
    }
}
function processRecords(kafka:AnydataConsumerRecord[] records) returns error? {
    foreach kafka:AnydataConsumerRecord rec in records {
        string stringValue = check string:fromBytes(check
rec.value.ensureType());
        check processStandardDelivery(stringValue);

    }
}
function processStandardDelivery(string requestStr) returns error? {
    json request = check value:fromJsonString(requestStr);
    log:printInfo(&quot;Processing standard delivery request: &quot; +
request.toJsonString());
    check sendConfirmation(request);
}
function sendConfirmation(json request) returns error? {
    kafka:Producer kafkaProducer = check createKafkaProducer();
    json confirmation = check createConfirmationJson(request);
    check sendKafkaMessage(kafkaProducer, confirmation);
    check kafkaProducer-&gt;&#39;close();
}
function createKafkaProducer() returns kafka:Producer|error {
    kafka:ProducerConfiguration producerConfigs = {
        clientId: &quot;standard-delivery-service&quot;,
        acks: &quot;all&quot;,
        retryCount: 3
    };
    return new (kafka:DEFAULT_URL, producerConfigs);
}
function createConfirmationJson(json request) returns json|error {
    return {
        &quot;requestId&quot;: check request.requestId,
        &quot;status&quot;: &quot;confirmed&quot;,
        &quot;pickupTime&quot;: &quot;2023-05-10T10:00:00Z&quot;,
        &quot;estimatedDeliveryTime&quot;: &quot;2023-05-12T14:00:00Z&quot;
    };
}
function sendKafkaMessage(kafka:Producer producer, json message) returns error? {
    byte[] serializedMsg = message.toJsonString().toBytes();
    check producer-&gt;send({
        topic: produceTopic,
        value: serializedMsg
    });
    check producer-&gt;&#39;flush();
}
